app.iam.create_role:
  RoleName: ${AWS_ROLE_NAME}
  Description: Role for sage aws app
  AssumeRolePolicyDocument: >
    {
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Principal": { 
            "Service": [
              "ec2.amazonaws.com",
              "eks.amazonaws.com",
              "route53.amazonaws.com",
              "rds.amazonaws.com",
              "ssm.amazonaws.com"
            ]
          },
          "Action": "sts:AssumeRole"
        }
      ]
    }
app.image.build:
  tag: ${DOCKER_REGISTRY}/${APP_REPO}:${APP_IMAGE_TAG}
  path: app
  dockerfile: Dockerfile
app.image.push:
  repository: ${DOCKER_REGISTRY}/${APP_REPO}
  tag: ${APP_IMAGE_TAG}
  auth_config:
    username: ${DOCKER_HUB_USERNAME}
    password: ${DOCKER_HUB_PASSWORD}
app.user.apple_client_secret:

db.iam.attach_role_policy.rds:
  RoleName: ${AWS_ROLE_NAME}
  PolicyArn: arn:aws:iam::aws:policy/AmazonRDSFullAccess
db.rds.create_db_parameter_group:
  DBParameterGroupName: ${DB_PARAMETER_GROUP_NAME}
  DBParameterGroupFamily: ${DB_PARAMETER_GROUP_FAMILY}
  Description: Sage parameter group
db.rds.modify_db_parameter_group:
  DBParameterGroupName: ${DB_PARAMETER_GROUP_NAME}
  Parameters:
    - ParameterName: rds.force_ssl
      ParameterValue: "0"
      ApplyMethod: immediate
db.rds.describe_db_parameter_groups:
  DBParameterGroupName: ${DB_PARAMETER_GROUP_NAME}
db.rds.create_db_instance:
  AllocatedStorage: 20
  DBInstanceClass: ${DB_INSTANCE_CLASS}
  DBName: ${POSTGRES_DB}
  DBInstanceIdentifier: ${APP_NAME}-${DB_SERVICE_NAME}
  DBParameterGroupName: ${DB_PARAMETER_GROUP_NAME}
  Engine: ${DB_ENGINE}
  MasterUsername: ${POSTGRES_USER}
  MasterUserPassword: ${POSTGRES_PASSWORD}

turn.iam.get_role:
  RoleName: ${AWS_ROLE_NAME}
turn.iam.create_instance_profile:
  InstanceProfileName: ${TURN_INSTANCE_PROFILE_NAME}
turn.iam.add_role_to_instance_profile:
  InstanceProfileName: ${TURN_INSTANCE_PROFILE_NAME}
  RoleName: ${AWS_ROLE_NAME}
turn.iam.attach_role_policy.ssm:
  RoleName: ${AWS_ROLE_NAME}
  PolicyArn: arn:aws:iam::aws:policy/AmazonSSMFullAccess
turn.ec2r.create_instances:
  ImageId: ${TURN_AMI_ID}
  InstanceType: ${TURN_INSTANCE_TYPE}
  MaxCount: 1
  MinCount: 1
  IamInstanceProfile:
    Name: ${TURN_INSTANCE_PROFILE_NAME}
turn.ec2_waiter.wait:
  InstanceIds:
    - $(turn.ec2r.create_instances.0.id)
turn.ssm.send_command:
  DocumentName: AWS-RunShellScript
  InstanceIds:
    - $(turn.ec2r.create_instances.0.id)
  Parameters:
    commands:
      - "ls -lah"
turn.ssm_waiter.wait:
  CommandId: $(turn.ssm.send_command.Command.CommandId)
  InstanceId: $(turn.ec2r.create_instances.0.id)
  WaiterConfig:
    Delay: 3
    MaxAttempts: 3
turn.ssm.get_command_invocation:
  CommandId: $(turn.ssm.send_command.Command.CommandId)
  InstanceId: $(turn.ec2r.create_instances.0.id)

kube.iam.create_policy.dns:
  PolicyName: ${EKS_DNS_POLICY_NAME}
  PolicyDocument: >
    {
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": "route53:*",
          "Resource": "*"
        }
      ]
    }
kube.iam.get_role:
  RoleName: ${AWS_ROLE_NAME}
kube.iam.attach_role_policy.dns:
  RoleName: ${AWS_ROLE_NAME}
  PolicyArn: arn:aws:iam::${AWS_ACCOUNT_ID}:policy/${EKS_DNS_POLICY_NAME}
kube.iam.attach_role_policy.eks_cluster:
  RoleName: ${AWS_ROLE_NAME}
  PolicyArn: arn:aws:iam::aws:policy/AmazonEKSClusterPolicy
kube.iam.attach_role_policy.eks_worker:
  RoleName: ${AWS_ROLE_NAME}
  PolicyArn: arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy
kube.iam.attach_role_policy.ec2:
  RoleName: ${AWS_ROLE_NAME}
  PolicyArn: arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
kube.iam.attach_role_policy.cni:
  RoleName: ${AWS_ROLE_NAME}
  PolicyArn: arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy
kube.ec2.describe_vpcs:
kube.ec2.describe_subnets:
  Filters:
    - Name: vpc-id
      Values:
        - $(kube.ec2.describe_vpcs.Vpcs.0.VpcId)
kube.ec2.describe_security_groups:
  GroupNames:
    - default
kube.eks.create_cluster:
  name: ${EKS_CLUSTER_NAME}
  version: "${EKS_VERSION}"
  roleArn: $(kube.iam.get_role.Role.Arn)
  resourcesVpcConfig:
    securityGroupIds:
      - $(kube.ec2.describe_security_groups.SecurityGroups.0.GroupId)
    subnetIds:
      - $(kube.ec2.describe_subnets.Subnets.0.SubnetId)
      - $(kube.ec2.describe_subnets.Subnets.1.SubnetId)
      - $(kube.ec2.describe_subnets.Subnets.2.SubnetId)
      - $(kube.ec2.describe_subnets.Subnets.3.SubnetId)
    endpointPublicAccess: true
kube.eks_waiter.wait:
  name: ${EKS_CLUSTER_NAME}
kube.eks.create_nodegroup:
  clusterName: ${EKS_CLUSTER_NAME}
  nodegroupName: ${EKS_NODE_GROUP_NAME}
  nodeRole: $(kube.iam.get_role.Role.Arn)
  subnets:
    - $(kube.ec2.describe_subnets.Subnets.0.SubnetId)
    - $(kube.ec2.describe_subnets.Subnets.1.SubnetId)
    - $(kube.ec2.describe_subnets.Subnets.2.SubnetId)
    - $(kube.ec2.describe_subnets.Subnets.3.SubnetId)
kube.user.binaries:
kube.user.init:
  account_id: ${AWS_ACCOUNT_ID}
  region: ${AWS_REGION}
  cluster_name: ${EKS_CLUSTER_NAME}
kube.user.deploy.sage:
  deployment: ${APP_NAME}
  chart: ./kube/app
kube.user.deploy.nginx:
  deployment: ${NGINX_NAME}
  chart: ingress-nginx/ingress-nginx
kube.user.deploy.certs:
  deployment: ${CERT_MANAGER_NAME}
  chart: jetstack/cert-manager
  values:
    installCRDs: true
  version: v1.13.3
kube.user.deploy.ingress:
  deployment: ${APP_INGRESS_NAME}
  chart: ./kube/ingress
---
db:
  - app
  - db

docker:
  - docker

kube:
  - docker
  - app
  - kube

turn:
  - turn
